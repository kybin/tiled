package main

type InputHandler interface {
	HandleInput() error
}

type ScreenDrawer interface {
	DrawScreen() error
}

type Game struct {
	Players []Player
	Table   *Table
}

func (g *Game) Save() error {
	return nil
}

func (g *Game) Load() error {
	return nil
}

type Table struct {
	Parties         []*Party
	CurrentParty    *Party
	WaitedParties   []*Party
	Allies          map[*Party][]*Party
	Tiles           []*Tile
	DefaultStrategy *Strategy
}

func (t *Table) TurnOver() {
	if len(t.WaitedParties) != 0 {
		t.CurrentParty = t.WaitedParties[0]
		t.WaitedParty = t.WaitedParty[1:]
	} else {
		nextPartyIdx := -1
		for i, p := range Parties {
			if p == t.CurrentParty {
				nextPartyIdx = i + 1
				break
			}
		}
		if nextPartyIdx == len(t.Parties) {
			nextPartyIdx = 0
		}
		t.CurrentParty = t.Parties[nextPartyIdx]
	}
	for _, c := range t.CurrentParty {
		c.Origin = c.At()
		c.Moves = nil
		c.SpentPoints = 0
	}
}

type Party struct {
	Table      *Table
	Characters []*Character
	Strategy   *Strategy
}

func (p *Party) IsAlly(q *Party) bool {
	allies := p.Table.Allies[p]
	for _, a := range allies {
		if q == a {
			return true
		}
	}
	return false
}

func (p *Party) AutoAction() {
	stg := p.Strategy
	if stg == nil {
		stg = p.Table.DefaultStrategy
	}
	if stg == nil {
		panic("default strategy should not be nil")
	}
	for _, np := range p.Characters {
		stg.Action(np)
	}
}

type Character struct {
	States      map[string]bool
	Party       *Party
	Origin      *Tile
	TotalPoints int
	SpentPoints int
	Moves       []Way
	AttackDirs  [][]string
	AttackPower int
	Skills      []Skill
	HP          int
}

func (c *Charactor) At() *Tile {
	if len(w.Moves) == 0 {
		return c.Origin
	}
	return w.Moves[len(w.Moves)-1].To
}

func (c *Character) Step(w Way) bool {
	if w.From != c.At() {
		return false
	}
	c.At().Occupier = nil
	c.Moves = append(c.Moves, w)
	c.At().Occupier = c
	return true
}

func (c *Character) MoveTo(t *Tile) {
	path := findPath(c.At(), t)
	if path == nil {
		return false
	}
	for _, w := range path {
		ok := c.Step(w)
		if !ok {
			return false
		}
	}
	return true
}

func (c *Character) Attack(t *Tile) {
	attackable := false
	for _, at := range c.AttackableTiles() {
		if at == t {
			attackable = true
		}
	}
	if !attackable {
		return
	}
	if t.Occupier != nil {
		return
	}
	if c.Party.IsAlly(t.Occupier.Party) {
		return
	}
	t.Occupier.HP -= c.AttackPower
	if t.Occupier.HP <= 0 {
		t.Occupier.State["dead"] = true
	}
}

func (c *Character) AttackableTiles() []*Tile {
	// eg) c.AttackDir == [["N", "E"], ["E", "S"], ["S", "W"], ["W", "N"]] would represent
	// the tiles marked with + for char @ in tiles generated by TileGenerator2D.
	// + +
	//  @
	// + +
	tiles := make([]*Tile, 0)
	for _, dirs := range c.AttackDirs {
		at := c.At()
		for _, d := range dirs {
			w := at.Way(d)
			if w == nil {
				continue
			}
			at = w.To
		}
		tiles = append(tiles, w)
	}
	return tiles
}

type Tile struct {
	Base     *TileBase
	Ways     []*Way
	Occupier *Character
}

func (t *Tile) Way(name string) *Way {
	for _, w := range t.Ways {
		if w.Name == name {
			return w
		}
	}
	return nil
}

type Way struct {
	Name string
	From *Tile
	To   *Tile
	Cost int
}

type TileGenerator2D struct {
	Size  Pos2D
	Bases []*TileBase
}

func (g *TileGenerator2D) Generate() []*Tile {
	xsize := g.Size[0]
	ysize := g.Size[1]
	tiles := make([]*Tile, len(g.Bases))
	emptyBase := &TileBase{}
	for i := range g.Base {
		tiles[i] = &Tile{}
	}
	for x := 0; x < xsize; x++ {
		for y := 0; y < ysize; y++ {
			idx := x*ysize + y
			t := g.Tiles[idx]
			if len(g.Bases) < i {
				t.Base = g.Bases[i]
			} else {
				t.Base = emptyBase
			}
			t.ways = make([]*Way, 0)
			if xsize != 0 {
				if x != 0 {
					t.Ways = append(t.Ways, &Way{Name: "W", From: t, To: tiles[idx-1], Cost: 1})
				}
				if x != xsize-1 {
					t.Ways = append(t.Ways, &Way{Name: "E", From: t, To: tiles[idx+1], Cost: 1})
				}
			}
			if ysize != 0 {
				if y != 0 {
					t.Ways = append(t.Ways, &Way{Name: "N", From: t, To: tiles[idx-xsize], Cost: 1})
				}
				if y != ysize-1 {
					t.Ways = append(t.Ways, &Way{Name: "S", From: t, To: tiles[idx+xsize], Cost: 1})
				}
			}
			g.Tiles[i] = t
		}
	}
}

type TileBase struct {
	Image *Image
}

type Interactable struct {
}

func findPath(a, b *Tile) *Path {
	// TODO
}

type Path struct {
	Ways []Way
	// Cost can be over or under to sum of costs of the Ways.
	// Caused by advantages of the Character. eg. Who can swim makes lake tile costs less.
	Cost int
}

func main() {
}
