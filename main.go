package main

type InputHandler interface {
	HandleInput() error
}

type ScreenDrawer interface {
	DrawScreen() error
}

type Game struct {
	Players []Player
	Table   *Table
}

func (g *Game) Save() error {
	return nil
}

func (g *Game) Load() error {
	return nil
}

type Table struct {
	Parties         []*Party
	CurrentParty    *Party
	WaitedParties   []*Party
	Allies          map[*Party][]*Party
	Tiles           []*Tile
	DefaultStrategy *Strategy
	PossibleWays    []string // eg. "N", "W", "S", "E"
}

func (t *Table) TurnOver() {
	if len(t.WaitedParties) != 0 {
		t.CurrentParty = t.WaitedParties[0]
		t.WaitedParty = t.WaitedParty[1:]
	} else {
		nextPartyIdx := -1
		for i, p := range Parties {
			if p == t.CurrentParty {
				nextPartyIdx = i + 1
				break
			}
		}
		if nextPartyIdx == len(t.Parties) {
			nextPartyIdx = 0
		}
		t.CurrentParty = t.Parties[nextPartyIdx]
	}
	for _, c := range t.CurrentParty {
		c.Origin = c.At()
		c.Moves = nil
		c.SpentPoints = 0
	}
}

type Party struct {
	Table      *Table
	Characters []*Character
	Strategy   *Strategy
}

func (p *Party) IsAlly(q *Party) bool {
	allies := p.Table.Allies[p]
	for _, a := range allies {
		if q == a {
			return true
		}
	}
	return false
}

func (p *Party) AutoAction() {
	stg := p.Strategy
	if stg == nil {
		stg = p.Table.DefaultStrategy
	}
	if stg == nil {
		panic("default strategy should not be nil")
	}
	for _, np := range p.Characters {
		stg.Action(np)
	}
}

type Character struct {
	States      map[string]bool
	Party       *Party
	Class       *Class
	Origin      *Tile
	TotalPoints int
	SpentPoints int
	Moves       []Way
	AttackDirs  [][]string
	AttackPower int
	Skills      map[string]Skill
	HP          int
}

func (c *Charactor) At() *Tile {
	if len(w.Moves) == 0 {
		return c.Origin
	}
	return w.Moves[len(w.Moves)-1].To
}

func (c *Character) Step(w Way) bool {
	if w.From != c.At() {
		return false
	}
	c.At().Occupier = nil
	c.Moves = append(c.Moves, w)
	c.At().Occupier = c
	return true
}

func (c *Character) MoveTo(t *Tile) {
	path := findPath(c.At(), t)
	if path == nil {
		return false
	}
	for _, w := range path {
		ok := c.Step(w)
		if !ok {
			return false
		}
	}
	return true
}

func (c *Character) Attack(t *Tile) {
	attackable := false
	for _, at := range c.AttackableTiles() {
		if at == t {
			attackable = true
		}
	}
	if !attackable {
		return
	}
	if t.Occupier != nil {
		return
	}
	if c.Party.IsAlly(t.Occupier.Party) {
		return
	}
	t.Occupier.HP -= c.AttackPower
	if t.Occupier.HP <= 0 {
		t.Occupier.State["dead"] = true
	}
}

func (c *Character) AttackableTiles() []*Tile {
	// eg) c.AttackDir == [["N", "E"], ["E", "S"], ["S", "W"], ["W", "N"]] would represent
	// the tiles marked with + for char @ in tiles generated by TileGenerator2D.
	// + +
	//  @
	// + +
	tiles := make([]*Tile, 0)
	for _, dirs := range c.AttackDirs {
		at := c.At()
		for _, d := range dirs {
			w := at.Way(d)
			if w == nil {
				continue
			}
			at = w.To
		}
		tiles = append(tiles, w)
	}
	return tiles
}

type Class struct {
	Skills []Skill
}

type Skill interface {
	Origin() *Tile
	SelectableArea() Area
	CastArea() Area
	Cast()
}

type Interactable struct {
}

func findPath(a, b *Tile) *Path {
	// TODO
}

type Path struct {
	Ways []Way
	// Cost can be over or under to sum of costs of the Ways.
	// Caused by advantages of the Character. eg. Who can swim makes lake tile costs less.
	Cost int
}

func main() {
}
