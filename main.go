package main

import "time"

type InputHandler interface {
	HandleInput() error
}

type ScreenDrawer interface {
	DrawScreen() error
}

type Game struct {
	Players []Player
	World   *World
}

func (g *Game) Save() error {
	return nil
}

func (g *Game) Load() error {
	return nil
}

type Stage interface {
	Win(*Party) bool
	Defeated(*Party) bool
	NoMorePlayer() bool
	Turn() int
	MaxTurns() int
}

type World struct {
	// Time will only passed on playing.
	// eg. Opening an UI will stop the world.
	Time time.Time
	// Board have Tiles with it's style, axis and sizes defined.
	Board *Board
	// Parties are all parties in the game.
	Parties []*Party
	// ActiveParty is the party currently acting, either by user or AI.
	ActiveParty *Party
	// WaitedParties will act before the next party of ActiveParty.
	WaitedParties []*Party
	// Allies are ally parties to Party.
	Allies map[*Party][]*Party
	// DefaultStrategy is the default AI strategy for NPC.
	// It should be defined so it can be used when an NPC doesn't have distinctive strategy.
	DefaultStrategy *Strategy
}

func (w *World) TurnOver() {
	if len(w.WaitedParties) != 0 {
		w.ActiveParty = w.WaitedParties[0]
		w.WaitedParty = w.WaitedParty[1:]
	} else {
		nextPartyIdx := -1
		for i, p := range Parties {
			if p == w.ActiveParty {
				nextPartyIdx = i + 1
				break
			}
		}
		if nextPartyIdx == len(w.Parties) {
			nextPartyIdx = 0
		}
		w.ActiveParty = w.Parties[nextPartyIdx]
	}
}

type Party struct {
	World      *World
	Characters []*Character
	Strategy   *Strategy
}

func (p *Party) IsAlly(q *Party) bool {
	allies := p.World.Allies[p]
	for _, a := range allies {
		if q == a {
			return true
		}
	}
	return false
}

func (p *Party) AutoAction() {
	stg := p.Strategy
	if stg == nil {
		stg = p.World.DefaultStrategy
	}
	if stg == nil {
		panic("default strategy should not be nil")
	}
	for _, np := range p.Characters {
		stg.Action(np)
	}
}

type Character struct {
	States      map[string]bool
	Party       *Party
	Class       *Class
	Origin      *Tile
	TotalPoints int
	SpentPoints int
	Moves       []Way
	AttackDirs  [][]string
	AttackPower int
	Skills      map[string]Skill
	HP          int
}

func (c *Charactor) Tile() *Tile {
	if len(w.Moves) == 0 {
		return c.Origin
	}
	return w.Moves[len(w.Moves)-1].To
}

func (c *Character) Step(w Way) bool {
	if w.From != c.Tile() {
		return false
	}
	c.Tile().Occupier = nil
	c.Moves = append(c.Moves, w)
	c.Tile().Occupier = c
	return true
}

func (c *Character) MoveTo(t *Tile) {
	path := findPath(c.Tile(), t)
	if path == nil {
		return false
	}
	for _, w := range path {
		ok := c.Step(w)
		if !ok {
			return false
		}
	}
	return true
}

func (c *Character) Attack(t *Tile) {
	attackable := false
	for _, at := range c.AttackableTiles() {
		if at == t {
			attackable = true
		}
	}
	if !attackable {
		return
	}
	if t.Occupier != nil {
		return
	}
	if c.Party.IsAlly(t.Occupier.Party) {
		return
	}
	t.Occupier.HP -= c.AttackPower
	if t.Occupier.HP <= 0 {
		t.Occupier.State["dead"] = true
	}
}

func (c *Character) AttackableTiles() []*Tile {
	// eg) c.AttackDir == [["N", "E"], ["E", "S"], ["S", "W"], ["W", "N"]] would represent
	// the tiles marked with + for char @ in tiles generated by TileGenerator2D.
	// + +
	//  @
	// + +
	tiles := make([]*Tile, 0)
	for _, dirs := range c.AttackDirs {
		at := c.Tile()
		for _, d := range dirs {
			w := at.Way(d)
			if w == nil {
				continue
			}
			at = w.To
		}
		tiles = append(tiles, w)
	}
	return tiles
}

func (c *Character) Done() {
	c.Origin = c.Tile()
	c.Moves = nil
	c.SpentPoints = 0
}

type Class struct {
	Skills []Skill
}

type Skill interface {
	Origin() *Tile
	SelectableArea() Area
	CastArea() Area
	Cast()
}

type Interactable struct {
}

func findPath(a, b *Tile) *Path {
	// TODO
}

type Path struct {
	Ways []Way
	// Cost can be over or under to sum of costs of the Ways.
	// Caused by advantages of the Character. eg. Who can swim makes lake tile costs less.
	Cost int
}

func main() {
}
