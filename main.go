package tiled

import (
	"image"
	"time"
)

type InputHandler interface {
	HandleInput() error
}

type ScreenDrawer interface {
	DrawScreen() error
}

type Game struct {
	Players        []Player
	World          *World
	EquipmentParts []string
	ItemTypes      []string
}

func (g *Game) Save() error {
	return nil
}

func (g *Game) Load() error {
	return nil
}

type Field struct{}

type Party struct {
	World      *World
	Characters []*Character
	Strategy   *Strategy
}

func (p *Party) IsAlly(q *Party) bool {
	allies := p.World.Allies[p]
	for _, a := range allies {
		if q == a {
			return true
		}
	}
	return false
}

func (p *Party) AutoAction() {
	stg := p.Strategy
	if stg == nil {
		stg = p.World.DefaultStrategy
	}
	if stg == nil {
		panic("default strategy should not be nil")
	}
	for _, np := range p.Characters {
		stg.Action(np)
	}
}

type Action struct {
	Name      string
	Sequence  []image.Image
	Lifetime  time.Duration
	Age       time.Duration
	Animation Animation
}

func (a *Action) Image() image.Image {
	n := len(a.Sequence)
	i := n * a.Age / a.Lifetime
	return a.Sequence[i]
}

type State struct {
	Name string
}

type Character struct {
	Party           *Party
	Class           *Class
	RestAction      *Action
	PendingActions  []*Action
	States          map[State]bool
	Equipments      map[string]*Item
	Items           []*Item
	Consumables     []*Consumable
	Origin          *Tile
	MaxPoints       int
	RemainingPoints int
	SpentPoints     int
	Moves           []Way
	AttackDirs      [][]string
	AttackPower     int
	Skills          map[string]Skill
	HP              int
}

func (c *Character) Tick(d time.Duration) {
	if len(c.PendingActions) == 0 {
		c.RestAction.Age = 0
		c.PendingActions = append(c.PendingActions, c.RestAction)
	}
	a := c.PendingActions[0]
	if a.Lifetime != 0 {
		a.Age += d
		if a.Age >= a.Lifetime {
			// finish the action
			c.PendingActions = c.PendingActions[1:]
		}
	}

}

func (c *Character) Tile() *Tile {
	if len(w.Moves) == 0 {
		return c.Origin
	}
	return w.Moves[len(w.Moves)-1].To
}

func (c *Character) Step(w Way) bool {
	if w.From != c.Tile() {
		return false
	}
	if w.To.Occupier != nil {
		return false
	}
	if c.RemainingPoints-c.SpentPoints < w.Cost {
		return false
	}
	w.From.Occupier = nil
	c.Moves = append(c.Moves, w)
	c.SpentPoints += w.Cost
	w.To.Occupier = c
	return true
}

func (c *Character) MoveTo(t *Tile) bool {
	path := findPath(c.Tile(), t)
	if path == nil {
		return false
	}
	for _, w := range path {
		ok := c.Step(w)
		if !ok {
			return false
		}
	}
	return true
}

func (c *Character) Attack(t *Tile) {
	attackable := false
	for _, at := range c.AttackableTiles() {
		if at == t {
			attackable = true
		}
	}
	if !attackable {
		return
	}
	if t.Occupier != nil {
		return
	}
	if c.Party.IsAlly(t.Occupier.Party) {
		return
	}
	t.Occupier.HP -= c.AttackPower
	if t.Occupier.HP <= 0 {
		t.Occupier.State["dead"] = true
	}
}

func (c *Character) AttackableTiles() []*Tile {
	// eg) c.AttackDir == [["N", "E"], ["E", "S"], ["S", "W"], ["W", "N"]] would represent
	// the tiles marked with + for char @ in tiles generated by TileGenerator2D.
	// + +
	//  @
	// + +
	tiles := make([]*Tile, 0)
	for _, dirs := range c.AttackDirs {
		at := c.Tile()
		for _, d := range dirs {
			w := at.Way(d)
			if w == nil {
				continue
			}
			at = w.To
		}
		tiles = append(tiles, w)
	}
	return tiles
}

// Commit makes Character cannot undo the previous actions.
// It is diffrent from Done as it doesn't end the chearacter's turn.
func (c *Character) Commit() {
	c.Origin = c.Tile()
	c.Moves = nil
	c.RemainingPoints -= c.SpentPoints
	c.SpentPoints = 0
}

// Done ends the character's turn.
func (c *Character) Done() {
	c.Origin = c.Tile()
	c.Moves = nil
	c.RemainingPoints = c.MaxPoints
	c.SpentPoints = 0
}

type Class struct {
	Skills []Skill
}

type Skill interface {
	Origin() *Tile
	SelectableArea() Area
	CastArea() Area
	Cast()
}

type Interactable struct {
}

func findPath(a, b *Tile) *Path {
	// TODO
}

type Path struct {
	Ways []Way
	// Cost can be over or under to sum of costs of the Ways.
	// Caused by advantages of the Character. eg. Who can swim makes lake tile costs less.
	Cost int
}

func main() {
}
